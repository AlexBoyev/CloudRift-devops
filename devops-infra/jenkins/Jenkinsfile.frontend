// Frontend Build and Deploy Pipeline
// Handles building, testing, and deploying the frontend service
// Uses SSH to connect to EC2 and run commands there

pipeline {
    agent any

    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
    }

    parameters {
        string(
            name: 'BRANCH_NAME',
            defaultValue: 'main',
            description: 'Git branch to build'
        )
        string(
            name: 'FRONTEND_REPO_URL',
            defaultValue: 'github.com/AlexBoyev/CloudRift-frontend.git',
            description: 'Frontend UI repo URL'
        )
        string(
            name: 'MINIKUBE_PROFILE',
            defaultValue: 'minikube',
            description: 'Minikube profile name'
        )
    }

    environment {
        BRANCH_NAME      = "${params.BRANCH_NAME ?: 'main'}"
        GITHUB_PAT       = credentials('github-pat-token')
        EC2_SSH_KEY      = credentials('ec2-ssh-key')
        EC2_USER         = 'ubuntu'
        EC2_HOST         = credentials('ec2-host-ip')

        // Paths & URLs
        FRONTEND_DIR     = '/home/ubuntu/frontend'
        DEVOPS_DIR       = '/home/ubuntu/new-devops-local'
        REPO_URL         = "${params.FRONTEND_REPO_URL}"
        MINIKUBE_PROFILE = "${params.MINIKUBE_PROFILE}"

        // DYNAMIC TAGGING: Unique per build + commit for traceability
        FRONTEND_TAG     = "frontend-${env.BUILD_NUMBER}-${GIT_COMMIT.take(8)}"
    }

    stages {
        stage('Clone Frontend Repo to EC2') {
            steps {
                script {
                    echo "==========================================="
                    echo "Frontend Pipeline - Cloning repository"
                    echo "Branch: ${params.BRANCH_NAME}"
                    echo "Tag: ${FRONTEND_TAG}"
                    echo "==========================================="
                }

                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} \
                          "BRANCH='${BRANCH_NAME}' REPO_URL='${REPO_URL}' REPO_DIR='${FRONTEND_DIR}' GITHUB_USER='${GITHUB_PAT_USR}' GITHUB_PASS='${GITHUB_PAT_PSW}' bash -s" <<'SCRIPT'
set -euo pipefail

# 1. HELPER: Normalize URL
normalize_url() {
  local input="$1"
  if echo "$input" | grep -qiE '^git@github.com:'; then
    input=$(echo "$input" | sed -E 's|^git@github.com:|https://github.com/|')
  elif echo "$input" | grep -qiE '^ssh://git@github.com/'; then
    input=$(echo "$input" | sed -E 's|^ssh://git@github.com/|https://github.com/|')
  elif ! echo "$input" | grep -qiE '^https?://'; then
    input="https://$input"
  fi
  echo "$input"
}

FULL_URL="$(normalize_url "$REPO_URL")"
TOKEN="${GITHUB_PASS:-}"

# 2. CONSTRUCT AUTH URL (The Fix)
# Strip "https://" to avoid duplication when embedding credentials
CLEAN_URL_NO_PROTO=$(echo "$FULL_URL" | sed -E 's|^https?://||')
# Use the embedded token format
AUTH_URL="https://${GITHUB_USER}:${TOKEN}@$CLEAN_URL_NO_PROTO"

echo "Cloning frontend repo: $FULL_URL"

# 3. CLONE/UPDATE LOGIC
if [ ! -d "$REPO_DIR/.git" ]; then
  mkdir -p "$REPO_DIR"
  echo "Cloning repository from branch: $BRANCH..."
  # Use AUTH_URL to clone directly
  git clone -b "$BRANCH" "$AUTH_URL" "$REPO_DIR"

  # Restore clean origin URL immediately
  git -C "$REPO_DIR" remote set-url origin "$FULL_URL" || true
else
  echo "Repository exists, pulling latest changes from branch: $BRANCH..."
  cd "$REPO_DIR"

  # FIX: FORCE PERMISSIONS FOR JENKINS (The Permission Denied Fix)
  sudo chown -R ubuntu:ubuntu "$REPO_DIR"
  sudo chmod -R u+rwX "$REPO_DIR"

  # Update remote URL with token temporarily
  git config --global --add safe.directory "$REPO_DIR"
  git remote set-url origin "$AUTH_URL"

  # Fetch using the token-embedded URL
  git fetch origin "$BRANCH" --prune --prune-tags || {
    echo "Fetch failed; check credentials or network."
    exit 1
  }

  # Reset and Clean
  git checkout -B "$BRANCH" "origin/$BRANCH"
  git reset --hard "origin/$BRANCH"
  git clean -fdx

  # Restore clean origin URL (do not persist PAT in .git/config)
  git remote set-url origin "$FULL_URL" || true
fi

cd "$REPO_DIR"
echo "Current branch: $(git branch --show-current)"
echo "Latest commit:  $(git rev-parse --short HEAD)"
SCRIPT
                    '''
                }
            }
        }

        stage('Build Docker Image on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} \
                           "FRONTEND_DIR='${FRONTEND_DIR}' MINIKUBE_PROFILE='${MINIKUBE_PROFILE}' FRONTEND_TAG='${FRONTEND_TAG}' bash -s" <<'SCRIPT'
set -euo pipefail

cd "$FRONTEND_DIR"

# Point Docker to Minikube daemon
eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"

echo "Using frontend tag: ${FRONTEND_TAG}"

# Remove old non-latest tags to save space
docker images ui-service --format '{{.Repository}}:{{.Tag}}' | grep '^ui-service:' | grep -v ':latest$' | xargs -r docker rmi -f || true
docker image prune -f || true

echo "Building Docker image: ui-service:${FRONTEND_TAG}"
docker build -t "ui-service:${FRONTEND_TAG}" .

echo "✓ Docker image built successfully with tag: ${FRONTEND_TAG}"
echo "Available images:"
docker images ui-service

# Cleanup intermediate tag (Kubernetes uses the specific tag directly via env var)
echo "Cleaning up intermediate frontend tag to save disk space..."
docker rmi "ui-service:${FRONTEND_TAG}" || true
docker image prune -f || true
SCRIPT
                    '''
                }
            }
        }

        stage('Deploy to Kubernetes on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} "
                            REPO_DIR='${DEVOPS_DIR}'
                            MINIKUBE_PROFILE='${MINIKUBE_PROFILE}'
                            FRONTEND_TAG='${FRONTEND_TAG}'

                            cd \\${REPO_DIR}

                            # Ensure kubectl context is set
                            kubectl config use-context \\${MINIKUBE_PROFILE} || true

                            # Apply Kubernetes manifests
                            echo 'Applying Frontend Manifests...'
                            kubectl apply -f devops-infra/kubernetes/frontend/configmap.yaml || true
                            kubectl apply -f devops-infra/kubernetes/frontend/deployment.yaml || true
                            kubectl apply -f devops-infra/kubernetes/frontend/service.yaml || true
                            kubectl apply -f devops-infra/kubernetes/frontend/hpa.yaml || true

                            # INJECT TAG: Set the exact frontend tag into deployment env
                            kubectl set env deployment/frontend-deployment FRONTEND_TAG=\\${FRONTEND_TAG} --containers=frontend || true

                            # Rollout restart with new tag
                            kubectl rollout restart deployment/frontend-deployment
                            kubectl rollout status deployment/frontend-deployment --timeout=300s || true

                            echo '✓ Frontend deployed successfully with tag: ${FRONTEND_TAG}'
                        "
                    '''
                }
            }
        }

        stage('Health Check') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} "
                            # Wait for pods to be ready
                            echo 'Waiting for health check...'
                            kubectl wait --for=condition=ready pod -l app=frontend --timeout=120s || true

                            # Get pod status
                            echo ''
                            echo '=== Frontend Pods (tag: ${FRONTEND_TAG}) ==='
                            kubectl get pods -l app=frontend -o wide

                            echo '✓ Health check passed'
                        "
                    '''
                }
            }
        }
    }

    post {
        success {
            echo "=========================================="
            echo "✓ Frontend Pipeline completed successfully!"
            echo "Tag: ${FRONTEND_TAG}"
            echo "=========================================="
        }
        failure {
            echo "✗ Frontend Pipeline failed!"
        }
    }
}
