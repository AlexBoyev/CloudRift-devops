pipeline {
    agent any

    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
    }

    parameters {
        string(name: 'BRANCH_NAME', defaultValue: 'main', description: 'Frontend branch to build')
        string(name: 'FRONTEND_REPO_URL', defaultValue: 'github.com/AlexBoyev/CloudRift-frontend.git', description: 'Frontend repo URL')
        string(name: 'DEVOPS_REPO_URL', defaultValue: 'https://github.com/AlexBoyev/CloudRift-devops.git', description: 'DevOps repo URL (manifests live here)')
        string(name: 'MINIKUBE_PROFILE', defaultValue: 'minikube', description: 'Minikube profile name')
    }

    environment {
        BRANCH_NAME      = "${params.BRANCH_NAME ?: 'main'}"
        GITHUB_PAT       = credentials('github-pat-token')
        EC2_USER         = 'ubuntu'
        EC2_HOST         = credentials('ec2-host-ip')

        FRONTEND_DIR     = '/home/ubuntu/new-frontend'
        REPO_DIR         = '/home/ubuntu/new-devops-local'

        FRONTEND_REPO_URL = "${params.FRONTEND_REPO_URL}"
        DEVOPS_REPO_URL   = "${params.DEVOPS_REPO_URL}"
        MINIKUBE_PROFILE  = "${params.MINIKUBE_PROFILE}"

        FRONTEND_SHA     = ""
        FRONTEND_TAG     = ""
    }

    stages {
        stage('Sync DevOps Repo on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} \
                          "GITHUB_PAT='${GITHUB_PAT}' GITHUB_USER='${GITHUB_PAT_USR}' DEVOPS_REPO='${DEVOPS_REPO_URL}' REPO_DIR='${REPO_DIR}' bash -s" <<'SCRIPT'
set -euo pipefail

normalize_url() {
  local input="$1"
  if echo "$input" | grep -qiE '^git@github.com:'; then
    input=$(echo "$input" | sed -E 's|^git@github.com:|https://github.com/|')
  elif echo "$input" | grep -qiE '^ssh://git@github.com/'; then
    input=$(echo "$input" | sed -E 's|^ssh://git@github.com/|https://github.com/|')
  elif ! echo "$input" | grep -qiE '^https?://'; then
    input="https://$input"
  fi
  echo "$input"
}

FULL_URL="$(normalize_url "$DEVOPS_REPO")"
TOKEN="${GITHUB_PAT}"
AUTH_B64="$(printf '%s' "${GITHUB_USER:-x-access-token}:$TOKEN" | base64 | tr -d '\n')"
AUTH_HEADER="Authorization: Basic $AUTH_B64"

if [ ! -d "$REPO_DIR/.git" ]; then
  mkdir -p "$REPO_DIR"
  git -c http.extraHeader="$AUTH_HEADER" clone "$FULL_URL" "$REPO_DIR"
else
  cd "$REPO_DIR"
  git config --global --add safe.directory "$REPO_DIR"
  git fetch --all
  git reset --hard origin/main
fi
SCRIPT
                    '''
                }
            }
        }

        stage('Sync Frontend Repo on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} \
                          "BRANCH='${BRANCH_NAME}' GITHUB_PAT='${GITHUB_PAT}' GITHUB_USER='${GITHUB_PAT_USR}' FE_REPO='${FRONTEND_REPO_URL}' FE_DIR='${FRONTEND_DIR}' bash -s" <<'SCRIPT'
set -euo pipefail
: "${BRANCH:=main}"

normalize_url() {
  local input="$1"
  if echo "$input" | grep -qiE '^git@github.com:'; then
    input=$(echo "$input" | sed -E 's|^git@github.com:|https://github.com/|')
  elif echo "$input" | grep -qiE '^ssh://git@github.com/'; then
    input=$(echo "$input" | sed -E 's|^ssh://git@github.com/|https://github.com/|')
  elif ! echo "$input" | grep -qiE '^https?://'; then
    input="https://$input"
  fi
  echo "$input"
}

FULL_URL="$(normalize_url "$FE_REPO")"
TOKEN="${GITHUB_PAT}"
AUTH_B64="$(printf '%s' "${GITHUB_USER:-x-access-token}:$TOKEN" | base64 | tr -d '\n')"
AUTH_HEADER="Authorization: Basic $AUTH_B64"

if [ ! -d "$FE_DIR/.git" ]; then
  mkdir -p "$FE_DIR"
  git -c http.extraHeader="$AUTH_HEADER" clone -b "$BRANCH" "$FULL_URL" "$FE_DIR"
else
  cd "$FE_DIR"
  git config --global --add safe.directory "$FE_DIR"
  git checkout "$BRANCH" || git checkout -b "$BRANCH" "origin/$BRANCH"
  git -c http.extraHeader="$AUTH_HEADER" pull "$FULL_URL" "$BRANCH" || {
    git fetch --all
    git reset --hard "origin/$BRANCH"
  }
fi

cd "$FE_DIR"
echo "Frontend SHA: $(git rev-parse --short HEAD)"
SCRIPT
                    '''
                }

                script {
                    def sha = sh(
                        script: "ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} \"cd ${FRONTEND_DIR} && git rev-parse --short HEAD\"",
                        returnStdout: true
                    ).trim()
                    env.FRONTEND_SHA = sha
                    env.FRONTEND_TAG = "frontend-${env.BUILD_NUMBER}-${sha}"
                    echo "Using FRONTEND_TAG=${env.FRONTEND_TAG}"
                }
            }
        }

        stage('Build Frontend Image on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} \
                           "FE_DIR='${FRONTEND_DIR}' MINIKUBE_PROFILE='${MINIKUBE_PROFILE}' FRONTEND_TAG='${FRONTEND_TAG}' bash -s" <<'SCRIPT'
set -euo pipefail

cd "$FE_DIR"
eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"

# Adjust Dockerfile context/path to your frontend repo layout:
# If your Dockerfile is at repo root: use "docker build -t ... ."
echo "Building ui-service:${FRONTEND_TAG}"
docker build -t "ui-service:${FRONTEND_TAG}" .

docker images | grep -E '^(ui-service)[[:space:]]' || true
SCRIPT
                    '''
                }
            }
        }

        stage('Deploy Frontend to Kubernetes on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} "
                            set -e
                            REPO_DIR='${REPO_DIR}'
                            MINIKUBE_PROFILE='${MINIKUBE_PROFILE}'
                            FRONTEND_TAG='${FRONTEND_TAG}'

                            cd \\${REPO_DIR}
                            kubectl config use-context \\${MINIKUBE_PROFILE} || true

                            # Apply your frontend manifests from devops repo (adjust paths as needed)
                            kubectl apply -f devops-infra/kubernetes/frontend/ || true

                            # Optional: inject tag into deployment env if your manifests support it
                            kubectl set env deployment/frontend-deployment FRONTEND_TAG=\\${FRONTEND_TAG} --containers=frontend || true

                            kubectl rollout restart deployment/frontend-deployment || true
                            kubectl rollout status deployment/frontend-deployment --timeout=300s || true

                            kubectl get pods -l app=frontend -o wide || true
                        "
                    '''
                }
            }
        }
    }

    post {
        success {
            echo "SUCCESS: FRONTEND_TAG=${FRONTEND_TAG} FRONTEND_SHA=${FRONTEND_SHA}"
        }
        failure {
            echo "FAILED: frontend pipeline"
        }
    }
}
