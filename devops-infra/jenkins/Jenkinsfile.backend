pipeline {
    agent any

    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
    }

    parameters {
        string(name: 'BRANCH_NAME', defaultValue: 'main', description: 'Backend branch to build')
        string(name: 'API_REPO_URL', defaultValue: 'github.com/AlexBoyev/CloudRift-backend.git', description: 'Backend repo URL')
        string(name: 'DEVOPS_REPO_URL', defaultValue: 'https://github.com/AlexBoyev/CloudRift-devops.git', description: 'DevOps repo URL (manifests live here)')
        string(name: 'MINIKUBE_PROFILE', defaultValue: 'minikube', description: 'Minikube profile name')
    }

    environment {
        BRANCH_NAME      = "${params.BRANCH_NAME ?: 'main'}"
        GITHUB_PAT       = credentials('github-pat-token')
        EC2_SSH_KEY      = credentials('ec2-ssh-key')
        EC2_USER         = 'ubuntu'
        EC2_HOST         = credentials('ec2-host-ip')

        API_DIR          = '/home/ubuntu/new-backend'
        REPO_DIR         = '/home/ubuntu/new-devops-local'

        API_REPO_URL     = "${params.API_REPO_URL}"
        DEVOPS_REPO_URL  = "${params.DEVOPS_REPO_URL}"
        MINIKUBE_PROFILE = "${params.MINIKUBE_PROFILE}"

        BACKEND_SHA      = ""
        BACKEND_TAG      = ""
    }

    stages {
        stage('Sync DevOps Repo on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} \
                          "GITHUB_PAT='${GITHUB_PAT}' GITHUB_USER='${GITHUB_PAT_USR}' DEVOPS_REPO='${DEVOPS_REPO_URL}' REPO_DIR='${REPO_DIR}' bash -s" <<'SCRIPT'
set -euo pipefail

normalize_url() {
  local input="$1"
  if echo "$input" | grep -qiE '^git@github.com:'; then
    input=$(echo "$input" | sed -E 's|^git@github.com:|https://github.com/|')
  elif echo "$input" | grep -qiE '^ssh://git@github.com/'; then
    input=$(echo "$input" | sed -E 's|^ssh://git@github.com/|https://github.com/|')
  elif ! echo "$input" | grep -qiE '^https?://'; then
    input="https://$input"
  fi
  echo "$input"
}

FULL_URL="$(normalize_url "$DEVOPS_REPO")"
TOKEN="${GITHUB_PAT}"
AUTH_B64="$(printf '%s' "${GITHUB_USER:-x-access-token}:$TOKEN" | base64 | tr -d '\n')"
AUTH_HEADER="Authorization: Basic $AUTH_B64"

if [ ! -d "$REPO_DIR/.git" ]; then
  mkdir -p "$REPO_DIR"
  echo "Cloning DevOps repo: $FULL_URL"
  git -c http.extraHeader="$AUTH_HEADER" clone "$FULL_URL" "$REPO_DIR"
else
  echo "Updating DevOps repo..."
  cd "$REPO_DIR"
  git config --global --add safe.directory "$REPO_DIR"
  git fetch --all
  git reset --hard origin/main
fi

cd "$REPO_DIR"
echo "DevOps commit: $(git rev-parse --short HEAD)"
SCRIPT
                    '''
                }
            }
        }

        stage('Sync Backend Repo on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} \
                          "BRANCH='${BRANCH_NAME}' GITHUB_PAT='${GITHUB_PAT}' GITHUB_USER='${GITHUB_PAT_USR}' API_REPO='${API_REPO_URL}' API_DIR='${API_DIR}' bash -s" <<'SCRIPT'
set -euo pipefail
: "${BRANCH:=main}"

normalize_url() {
  local input="$1"
  if echo "$input" | grep -qiE '^git@github.com:'; then
    input=$(echo "$input" | sed -E 's|^git@github.com:|https://github.com/|')
  elif echo "$input" | grep -qiE '^ssh://git@github.com/'; then
    input=$(echo "$input" | sed -E 's|^ssh://git@github.com/|https://github.com/|')
  elif ! echo "$input" | grep -qiE '^https?://'; then
    input="https://$input"
  fi
  echo "$input"
}

FULL_URL="$(normalize_url "$API_REPO")"
TOKEN="${GITHUB_PAT}"
AUTH_B64="$(printf '%s' "${GITHUB_USER:-x-access-token}:$TOKEN" | base64 | tr -d '\n')"
AUTH_HEADER="Authorization: Basic $AUTH_B64"

if [ ! -d "$API_DIR/.git" ]; then
  mkdir -p "$API_DIR"
  echo "Cloning backend repo: $FULL_URL (branch: $BRANCH)"
  git -c http.extraHeader="$AUTH_HEADER" clone -b "$BRANCH" "$FULL_URL" "$API_DIR"
else
  echo "Updating backend repo (branch: $BRANCH)..."
  cd "$API_DIR"
  git config --global --add safe.directory "$API_DIR"
  git checkout "$BRANCH" || git checkout -b "$BRANCH" "origin/$BRANCH"
  git -c http.extraHeader="$AUTH_HEADER" pull "$FULL_URL" "$BRANCH" || {
    echo "Pull failed, resetting..."
    git fetch --all
    git reset --hard "origin/$BRANCH"
  }
fi

cd "$API_DIR"
echo "Backend SHA: $(git rev-parse --short HEAD)"
SCRIPT
                    '''
                }

                script {
                    def sha = sh(
                        script: "ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} \"cd ${API_DIR} && git rev-parse --short HEAD\"",
                        returnStdout: true
                    ).trim()
                    env.BACKEND_SHA = sha
                    env.BACKEND_TAG = "backend-${env.BUILD_NUMBER}-${sha}"
                    echo "Using BACKEND_TAG=${env.BACKEND_TAG}"
                }
            }
        }

        stage('Build Docker Images on EC2') {
            options {
                retry(3)
                timeout(time: 20, unit: 'MINUTES')
            }
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} \
                           "API_DIR='${API_DIR}' MINIKUBE_PROFILE='${MINIKUBE_PROFILE}' BACKEND_TAG='${BACKEND_TAG}' bash -s" <<'SCRIPT'
set -euo pipefail
cd "$API_DIR"

eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
echo "Building tag: ${BACKEND_TAG}"

cleanup_repo() {
  local repo="$1"
  docker images "$repo" --format '{{.Repository}}:{{.Tag}}' \
    | grep "^${repo}:" \
    | grep -v ":latest$" \
    | grep -v ":${BACKEND_TAG}$" \
    | xargs -r docker rmi -f || true
}

cleanup_repo backend-service
cleanup_repo stack-service
cleanup_repo linkedlist-service
cleanup_repo graph-service
cleanup_repo postgres-db
docker image prune -f || true

docker build -t "backend-service:${BACKEND_TAG}" -f backend/Dockerfile backend/
docker build -t "stack-service:${BACKEND_TAG}" -f stack/Dockerfile ./
docker build -t "linkedlist-service:${BACKEND_TAG}" -f linkedlist/Dockerfile ./
docker build -t "graph-service:${BACKEND_TAG}" -f graph/Dockerfile ./
docker build -t "postgres-db:${BACKEND_TAG}" -f database/Dockerfile ./

echo "Images built:"
docker images | grep -E '^(backend-service|stack-service|linkedlist-service|graph-service|postgres-db)[[:space:]]' || true
SCRIPT
                    '''
                }
            }
        }

        stage('Deploy to Kubernetes on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh '''
                        ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} "
                            set -e

                            REPO_DIR='${REPO_DIR}'
                            MINIKUBE_PROFILE='${MINIKUBE_PROFILE}'
                            BACKEND_TAG='${BACKEND_TAG}'

                            cd \\${REPO_DIR}

                            kubectl config use-context \\${MINIKUBE_PROFILE} || true

                            kubectl apply -f devops-infra/kubernetes/database/secret.yaml || true
                            kubectl apply -f devops-infra/kubernetes/database/service.yaml || true
                            kubectl apply -f devops-infra/kubernetes/database/statefulset.yaml || true

                            kubectl apply -f devops-infra/kubernetes/backend/configmap.yaml   || true
                            kubectl apply -f devops-infra/kubernetes/backend/secret.yaml      || true
                            kubectl apply -f devops-infra/kubernetes/backend/deployment.yaml  || true
                            kubectl apply -f devops-infra/kubernetes/backend/service.yaml     || true
                            kubectl apply -f devops-infra/kubernetes/ingress/ingress.yaml     || true
                            kubectl apply -f devops-infra/kubernetes/backend/hpa.yaml         || true

                            kubectl set env deployment/backend-deployment BACKEND_TAG=\\${BACKEND_TAG} --containers=backend || true

                            kubectl apply -f devops-infra/kubernetes/data-structures/stack.yaml      || true
                            kubectl apply -f devops-infra/kubernetes/data-structures/linkedlist.yaml || true
                            kubectl apply -f devops-infra/kubernetes/data-structures/graph.yaml      || true

                            kubectl rollout restart deployment/backend-deployment
                            kubectl rollout status deployment/backend-deployment --timeout=300s || true

                            echo ''
                            echo '=== Services ==='
                            kubectl get svc -o wide || true

                            echo ''
                            echo '=== Backend Pods ==='
                            kubectl get pods -l app=backend -o wide || true
                        "
                    '''
                }
            }
        }
    }

    post {
        success {
            echo "SUCCESS: BACKEND_TAG=${BACKEND_TAG} BACKEND_SHA=${BACKEND_SHA}"
        }
        failure {
            echo "FAILED: backend pipeline"
        }
    }
}
