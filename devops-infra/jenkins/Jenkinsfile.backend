pipeline {
    agent any

    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
    }

    parameters {
        string(name: 'BRANCH_NAME', defaultValue: 'main', description: 'Backend branch to build')
        string(name: 'API_REPO_URL', defaultValue: 'github.com/AlexBoyev/CloudRift-backend.git', description: 'Backend repo URL')
        string(name: 'DEVOPS_REPO_URL', defaultValue: 'https://github.com/AlexBoyev/CloudRift-devops.git', description: 'DevOps repo URL (manifests live here)')
        string(name: 'MINIKUBE_PROFILE', defaultValue: 'minikube', description: 'Minikube profile name')
    }

    environment {
        BRANCH_NAME      = "${params.BRANCH_NAME ?: 'main'}"

        // Must be Username/Password credential; token is in *_PSW
        GITHUB_PAT       = credentials('github-pat-token')

        // SSH Username with private key credential
        EC2_SSH_KEY      = credentials('ec2-ssh-key')

        EC2_USER         = 'ubuntu'
        // Secret text credential containing only host/dns/ip (no protocol, no port)
        EC2_HOST         = credentials('ec2-host-ip')

        API_DIR          = '/home/ubuntu/new-backend'
        REPO_DIR         = '/home/ubuntu/new-devops-local'

        API_REPO_URL     = "${params.API_REPO_URL}"
        DEVOPS_REPO_URL  = "${params.DEVOPS_REPO_URL}"
        MINIKUBE_PROFILE = "${params.MINIKUBE_PROFILE}"

        BACKEND_SHA      = ""
        BACKEND_TAG      = ""
    }

    stages {

        stage('Sync DevOps Repo on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh(label: 'Sync DevOps repo', script: '''bash -lc '
set -euo pipefail

ssh -o StrictHostKeyChecking=no -o IdentitiesOnly=yes \
  "${EC2_USER}@${EC2_HOST}" \
  "GITHUB_PAT=\\"${GITHUB_PAT_PSW}\\" DEVOPS_REPO=\\"${DEVOPS_REPO_URL}\\" REPO_DIR=\\"${REPO_DIR}\\" bash -s" <<'"'"'SCRIPT'"'"'
set -euo pipefail

normalize_url() {
  local input="$1"
  if echo "$input" | grep -qiE "^git@github.com:"; then
    input=$(echo "$input" | sed -E "s|^git@github.com:|https://github.com/|")
  elif echo "$input" | grep -qiE "^ssh://git@github.com/"; then
    input=$(echo "$input" | sed -E "s|^ssh://git@github.com/|https://github.com/|")
  elif ! echo "$input" | grep -qiE "^https?://"; then
    input="https://$input"
  fi
  echo "$input"
}

FULL_URL="$(normalize_url "$DEVOPS_REPO")"
AUTH_URL="$FULL_URL"

if echo "$FULL_URL" | grep -qiE "^https://github.com/"; then
  AUTH_URL="$(echo "$FULL_URL" | sed -E "s|^https://github.com/|https://x-access-token:${GITHUB_PAT}@github.com/|")"
fi

if [ ! -d "$REPO_DIR/.git" ]; then
  mkdir -p "$REPO_DIR"
  echo "Cloning DevOps repo..."
  git clone "$AUTH_URL" "$REPO_DIR"
else
  echo "Updating DevOps repo..."
  cd "$REPO_DIR"
  git config --global --add safe.directory "$REPO_DIR"
  git remote set-url origin "$AUTH_URL" || true
  git fetch --all
  git reset --hard origin/main
fi

cd "$REPO_DIR"
echo "DevOps commit: $(git rev-parse --short HEAD)"
SCRIPT
' ''')
                }
            }
        }

        stage('Sync Backend Repo on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {

                    sh(label: 'Sync backend repo', script: '''bash -lc '
set -euo pipefail

ssh -o StrictHostKeyChecking=no -o IdentitiesOnly=yes \
  "${EC2_USER}@${EC2_HOST}" \
  "BRANCH=\\"${BRANCH_NAME}\\" GITHUB_PAT=\\"${GITHUB_PAT_PSW}\\" API_REPO=\\"${API_REPO_URL}\\" API_DIR=\\"${API_DIR}\\" bash -s" <<'"'"'SCRIPT'"'"'
set -euo pipefail
: "${BRANCH:=main}"

normalize_url() {
  local input="$1"
  if echo "$input" | grep -qiE "^git@github.com:"; then
    input=$(echo "$input" | sed -E "s|^git@github.com:|https://github.com/|")
  elif echo "$input" | grep -qiE "^ssh://git@github.com/"; then
    input=$(echo "$input" | sed -E "s|^ssh://git@github.com/|https://github.com/|")
  elif ! echo "$input" | grep -qiE "^https?://"; then
    input="https://$input"
  fi
  echo "$input"
}

FULL_URL="$(normalize_url "$API_REPO")"
AUTH_URL="$FULL_URL"

if echo "$FULL_URL" | grep -qiE "^https://github.com/"; then
  AUTH_URL="$(echo "$FULL_URL" | sed -E "s|^https://github.com/|https://x-access-token:${GITHUB_PAT}@github.com/|")"
fi

if [ ! -d "$API_DIR/.git" ]; then
  mkdir -p "$API_DIR"
  echo "Cloning backend repo (branch: $BRANCH)..."
  git clone -b "$BRANCH" "$AUTH_URL" "$API_DIR"
else
  echo "Updating backend repo (branch: $BRANCH)..."
  cd "$API_DIR"
  git config --global --add safe.directory "$API_DIR"
  git remote set-url origin "$AUTH_URL" || true

  git fetch --all
  git checkout "$BRANCH" || git checkout -b "$BRANCH" "origin/$BRANCH"
  git pull origin "$BRANCH" || {
    echo "Pull failed, resetting..."
    git fetch --all
    git reset --hard "origin/$BRANCH"
  }
fi

cd "$API_DIR"
echo "Backend SHA: $(git rev-parse --short HEAD)"
SCRIPT
' ''')

                    // IMPORTANT: must run while sshagent is active, otherwise you get "Permission denied (publickey)"
                    script {
                        def sha = sh(
                            script: '''bash -lc '
set -euo pipefail
ssh -o StrictHostKeyChecking=no -o IdentitiesOnly=yes \
  "${EC2_USER}@${EC2_HOST}" \
  "cd ${API_DIR} && git rev-parse --short HEAD"
' ''',
                            returnStdout: true
                        ).trim()

                        env.BACKEND_SHA = sha
                        env.BACKEND_TAG = "backend-${env.BUILD_NUMBER}-${sha}"
                        echo "Using BACKEND_TAG=${env.BACKEND_TAG}"
                    }
                }
            }
        }

        stage('Build Docker Images on EC2') {
            options {
                retry(3)
                timeout(time: 20, unit: 'MINUTES')
            }
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh(label: 'Build images', script: '''bash -lc '
set -euo pipefail

ssh -o StrictHostKeyChecking=no -o IdentitiesOnly=yes \
  "${EC2_USER}@${EC2_HOST}" \
  "API_DIR=\\"${API_DIR}\\" MINIKUBE_PROFILE=\\"${MINIKUBE_PROFILE}\\" BACKEND_TAG=\\"${BACKEND_TAG}\\" bash -s" <<'"'"'SCRIPT'"'"'
set -euo pipefail
cd "$API_DIR"

eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
echo "Building tag: ${BACKEND_TAG}"

cleanup_repo() {
  local repo="$1"
  docker images "$repo" --format "{{.Repository}}:{{.Tag}}" \
    | grep "^${repo}:" \
    | grep -v ":latest$" \
    | grep -v ":${BACKEND_TAG}$" \
    | xargs -r docker rmi -f || true
}

cleanup_repo backend-service
cleanup_repo stack-service
cleanup_repo linkedlist-service
cleanup_repo graph-service
cleanup_repo postgres-db
docker image prune -f || true

docker build -t "backend-service:${BACKEND_TAG}" -f backend/Dockerfile backend/
docker build -t "stack-service:${BACKEND_TAG}" -f stack/Dockerfile ./
docker build -t "linkedlist-service:${BACKEND_TAG}" -f linkedlist/Dockerfile ./
docker build -t "graph-service:${BACKEND_TAG}" -f graph/Dockerfile ./
docker build -t "postgres-db:${BACKEND_TAG}" -f database/Dockerfile ./

echo "Images built:"
docker images | grep -E "^(backend-service|stack-service|linkedlist-service|graph-service|postgres-db)[[:space:]]" || true
SCRIPT
' ''')
                }
            }
        }

        stage('Deploy to Kubernetes on EC2') {
            steps {
                sshagent(credentials: ['ec2-ssh-key']) {
                    sh(label: 'Deploy', script: '''bash -lc '
set -euo pipefail

ssh -o StrictHostKeyChecking=no -o IdentitiesOnly=yes \
  "${EC2_USER}@${EC2_HOST}" "
  set -e
  cd ${REPO_DIR}
  kubectl config use-context ${MINIKUBE_PROFILE} || true

  kubectl apply -f devops-infra/kubernetes/database/secret.yaml      || true
  kubectl apply -f devops-infra/kubernetes/database/service.yaml     || true
  kubectl apply -f devops-infra/kubernetes/database/statefulset.yaml || true

  kubectl apply -f devops-infra/kubernetes/backend/configmap.yaml   || true
  kubectl apply -f devops-infra/kubernetes/backend/secret.yaml      || true
  kubectl apply -f devops-infra/kubernetes/backend/deployment.yaml  || true
  kubectl apply -f devops-infra/kubernetes/backend/service.yaml     || true
  kubectl apply -f devops-infra/kubernetes/ingress/ingress.yaml     || true
  kubectl apply -f devops-infra/kubernetes/backend/hpa.yaml         || true

  kubectl rollout restart deployment/backend-deployment
  kubectl rollout status deployment/backend-deployment --timeout=300s || true

  echo ''
  echo '=== Services ==='
  kubectl get svc -o wide || true

  echo ''
  echo '=== Backend Pods ==='
  kubectl get pods -l app=backend -o wide || true
"
' ''')
                }
            }
        }
    }

    post {
        success {
            echo "SUCCESS: BACKEND_TAG=${BACKEND_TAG} BACKEND_SHA=${BACKEND_SHA}"
        }
        failure {
            echo "FAILED: backend pipeline"
        }
    }
}
