pipeline {
    agent any

    options {
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
    }

    environment {
        // Get EC2 host from credentials (stored as secret text)
        EC2_HOST = credentials('ec2-host-ip')
        EC2_USER = 'ubuntu'

        // Repo URLs and directories
        DEVOPS_REPO_URL = 'https://github.com/AlexBoyev/CloudRift-devops.git'
        API_REPO_URL = 'https://github.com/AlexBoyev/CloudRift-backend.git'
        REPO_DIR = '/home/ubuntu/CloudRift-devops'
        API_DIR = '/home/ubuntu/CloudRift-backend'
        BRANCH_NAME = 'main'
        MINIKUBE_PROFILE = 'minikube'

        // Jenkins credentials IDs
        GITHUB_PAT_CRED = 'github-pat-token'
        EC2_SSH_CRED = 'ec2-ssh-key'

        BACKEND_SHA = ''
        BACKEND_TAG = ''
    }

    stages {

        stage('Checkout DevOps Repo') {
            steps {
                checkout scm
            }
        }

        stage('SSH Preflight') {
            steps {
                sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                    sh """#!/bin/bash
set -euo pipefail

echo "Testing SSH connection to: ${EC2_HOST}"

ssh -o StrictHostKeyChecking=no \
    -o PreferredAuthentications=publickey \
    -o PubkeyAuthentication=yes \
    -o ConnectTimeout=10 \
    "${EC2_USER}@${EC2_HOST}" \
    'echo "SSH connection successful"'
"""
                }
            }
        }

        stage('Sync DevOps Repo on EC2') {
            steps {
                withCredentials([
                    usernamePassword(credentialsId: "${env.GITHUB_PAT_CRED}", usernameVariable: 'GITHUB_PAT_USR', passwordVariable: 'GITHUB_PAT_PSW')
                ]) {
                    sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                        sh """#!/bin/bash
set -euo pipefail

# Execute the sync script on EC2
ssh -o StrictHostKeyChecking=no \
    -o PreferredAuthentications=publickey \
    -o PubkeyAuthentication=yes \
    "${EC2_USER}@${EC2_HOST}" bash -s <<'ENDSSH'
set -euo pipefail

GITHUB_PAT="${GITHUB_PAT_PSW}"
DEVOPS_REPO="${DEVOPS_REPO_URL}"
REPO_DIR="${REPO_DIR}"

normalize_url() {
  local input="\$1"
  if echo "\$input" | grep -qiE '^git@github.com:'; then
    input=\$(echo "\$input" | sed -E 's|^git@github.com:|https://github.com/|')
  elif echo "\$input" | grep -qiE '^ssh://git@github.com/'; then
    input=\$(echo "\$input" | sed -E 's|^ssh://git@github.com/|https://github.com/|')
  elif ! echo "\$input" | grep -qiE '^https?://'; then
    input="https://\$input"
  fi
  echo "\$input"
}

FULL_URL="\$(normalize_url "\$DEVOPS_REPO")"
AUTH_URL="\$FULL_URL"

if echo "\$FULL_URL" | grep -qiE '^https://github.com/'; then
  AUTH_URL="\$(echo "\$FULL_URL" | sed -E "s|^https://github.com/|https://x-access-token:\${GITHUB_PAT}@github.com/|")"
fi

if [ ! -d "\$REPO_DIR/.git" ]; then
  mkdir -p "\$REPO_DIR"
  echo "Cloning DevOps repo..."
  git clone "\$AUTH_URL" "\$REPO_DIR"
else
  echo "Updating DevOps repo..."
  cd "\$REPO_DIR"
  git config --global --add safe.directory "\$REPO_DIR" || true
  git remote set-url origin "\$AUTH_URL" || true
  git fetch --all --prune
  git reset --hard origin/main
fi

cd "\$REPO_DIR"
echo "DevOps commit: \$(git rev-parse --short HEAD)"
ENDSSH
"""
                    }
                }
            }
        }

        stage('Sync Backend Repo on EC2') {
            steps {
                withCredentials([
                    usernamePassword(credentialsId: "${env.GITHUB_PAT_CRED}", usernameVariable: 'GITHUB_PAT_USR', passwordVariable: 'GITHUB_PAT_PSW')
                ]) {
                    sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                        sh """#!/bin/bash
set -euo pipefail

# Execute the sync script on EC2
ssh -o StrictHostKeyChecking=no \
    -o PreferredAuthentications=publickey \
    -o PubkeyAuthentication=yes \
    "${EC2_USER}@${EC2_HOST}" bash -s <<'ENDSSH'
set -euo pipefail

BRANCH="${BRANCH_NAME}"
GITHUB_PAT="${GITHUB_PAT_PSW}"
API_REPO="${API_REPO_URL}"
API_DIR="${API_DIR}"

normalize_url() {
  local input="\$1"
  if echo "\$input" | grep -qiE '^git@github.com:'; then
    input=\$(echo "\$input" | sed -E 's|^git@github.com:|https://github.com/|')
  elif echo "\$input" | grep -qiE '^ssh://git@github.com/'; then
    input=\$(echo "\$input" | sed -E 's|^ssh://git@github.com/|https://github.com/|')
  elif ! echo "\$input" | grep -qiE '^https?://'; then
    input="https://\$input"
  fi
  echo "\$input"
}

FULL_URL="\$(normalize_url "\$API_REPO")"
AUTH_URL="\$FULL_URL"

if echo "\$FULL_URL" | grep -qiE '^https://github.com/'; then
  AUTH_URL="\$(echo "\$FULL_URL" | sed -E "s|^https://github.com/|https://x-access-token:\${GITHUB_PAT}@github.com/|")"
fi

if [ ! -d "\$API_DIR/.git" ]; then
  mkdir -p "\$API_DIR"
  echo "Cloning backend repo (branch: \$BRANCH)..."
  git clone -b "\$BRANCH" "\$AUTH_URL" "\$API_DIR"
else
  echo "Updating backend repo (branch: \$BRANCH)..."
  cd "\$API_DIR"
  git config --global --add safe.directory "\$API_DIR" || true
  git remote set-url origin "\$AUTH_URL" || true
  git fetch --all --prune
  git checkout "\$BRANCH" || git checkout -b "\$BRANCH" "origin/\$BRANCH"
  git pull origin "\$BRANCH" || {
    echo "Pull failed, resetting..."
    git fetch --all
    git reset --hard "origin/\$BRANCH"
  }
fi

cd "\$API_DIR"
echo "Backend SHA: \$(git rev-parse --short HEAD)"
ENDSSH
"""
                    }
                }
            }
        }

        stage('Compute BACKEND_TAG') {
            steps {
                sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                    script {
                        def bn = (env.BUILD_NUMBER ?: "${currentBuild.number}").toString()

                        def sha = sh(
                            label: 'Read backend SHA from EC2',
                            script: """#!/bin/bash
set -euo pipefail
ssh -o StrictHostKeyChecking=no \
    -o PreferredAuthentications=publickey \
    -o PubkeyAuthentication=yes \
    "${EC2_USER}@${EC2_HOST}" \
    "cd ${API_DIR} && git rev-parse --short HEAD | tr -d \\r"
""",
                            returnStdout: true
                        ).trim()

                        if (!sha) {
                            error("ERROR: backend SHA came back empty; cannot build a tag")
                        }

                        env.BACKEND_SHA = sha
                        env.BACKEND_TAG = "backend-${bn}-${sha}"

                        if (!env.BACKEND_TAG?.trim() || env.BACKEND_TAG == 'null') {
                            error("ERROR: BACKEND_TAG resolved to an invalid value: '${env.BACKEND_TAG}'")
                        }

                        echo "Using BACKEND_SHA=${env.BACKEND_SHA}"
                        echo "Using BACKEND_TAG=${env.BACKEND_TAG}"
                    }
                }
            }
        }

        stage('Build Docker Images on EC2') {
            options {
                retry(3)
                timeout(time: 20, unit: 'MINUTES')
            }
            steps {
                sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                    sh """#!/bin/bash
set -euo pipefail

echo "Building images with tag: ${BACKEND_TAG}"

# Execute the build script on EC2
ssh -o StrictHostKeyChecking=no \
    -o PreferredAuthentications=publickey \
    -o PubkeyAuthentication=yes \
    "${EC2_USER}@${EC2_HOST}" bash -s <<'ENDSSH'
set -euo pipefail

API_DIR="${API_DIR}"
MINIKUBE_PROFILE="${MINIKUBE_PROFILE}"
BACKEND_TAG="${BACKEND_TAG}"

cd "\$API_DIR"

eval "\$(minikube -p "\${MINIKUBE_PROFILE}" docker-env)"
echo "Building tag: \${BACKEND_TAG}"

cleanup_repo() {
  local repo="\$1"
  docker images "\$repo" --format "{{.Repository}}:{{.Tag}}" \
    | grep "^\${repo}:" \
    | grep -v ":latest\$" \
    | grep -v ":\${BACKEND_TAG}\$" \
    | xargs -r docker rmi -f || true
}

cleanup_repo backend-service
cleanup_repo stack-service
cleanup_repo linkedlist-service
cleanup_repo graph-service
cleanup_repo postgres-db

docker image prune -f || true

docker build -t "backend-service:\${BACKEND_TAG}"    -f backend/Dockerfile     backend/
docker build -t "stack-service:\${BACKEND_TAG}"      -f stack/Dockerfile       ./
docker build -t "linkedlist-service:\${BACKEND_TAG}" -f linkedlist/Dockerfile  ./
docker build -t "graph-service:\${BACKEND_TAG}"      -f graph/Dockerfile       ./
docker build -t "postgres-db:\${BACKEND_TAG}"        -f database/Dockerfile    ./

# Tag all images as latest as well
docker tag "backend-service:\${BACKEND_TAG}" "backend-service:latest"
docker tag "stack-service:\${BACKEND_TAG}" "stack-service:latest"
docker tag "linkedlist-service:\${BACKEND_TAG}" "linkedlist-service:latest"
docker tag "graph-service:\${BACKEND_TAG}" "graph-service:latest"
docker tag "postgres-db:\${BACKEND_TAG}" "postgres-db:latest"

echo "Images built:"
docker images | grep -E '^(backend-service|stack-service|linkedlist-service|graph-service|postgres-db)[[:space:]]' || true
ENDSSH
"""
                }
            }
        }

        stage('Deploy to Kubernetes on EC2') {
            steps {
                sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                    sh """#!/bin/bash
set -euo pipefail

echo "Deploying to Kubernetes with tag: ${BACKEND_TAG}"

# Execute the deploy script on EC2
ssh -o StrictHostKeyChecking=no \
    -o PreferredAuthentications=publickey \
    -o PubkeyAuthentication=yes \
    "${EC2_USER}@${EC2_HOST}" bash -s <<'ENDSSH'
set -euo pipefail

REPO_DIR="${REPO_DIR}"
API_DIR="${API_DIR}"
MINIKUBE_PROFILE="${MINIKUBE_PROFILE}"
BACKEND_TAG="${BACKEND_TAG}"

eval "\$(minikube -p "\${MINIKUBE_PROFILE}" docker-env)"

cd "\$REPO_DIR"
echo "Deploying tag \${BACKEND_TAG}..."

if [ -d devops-infra/k8s/backend ]; then
  find devops-infra/k8s/backend -type f -name '*.yaml' -print0 \
    | xargs -0 -I{} bash -c "sed \"s|IMAGE_TAG|\${BACKEND_TAG}|g\" {} | kubectl apply -f -"
else
  echo "WARNING: devops-infra/k8s/backend not found. Trying kubernetes/backend..."
  if [ -d devops-infra/kubernetes/backend ]; then
    find devops-infra/kubernetes/backend -type f -name '*.yaml' -print0 \
      | xargs -0 -I{} bash -c "sed \"s|IMAGE_TAG|\${BACKEND_TAG}|g\" {} | kubectl apply -f -"
  else
    echo "ERROR: No backend kubernetes manifests found. Skipping deployment."
  fi
fi

# Also deploy data structures if they exist
if [ -d devops-infra/kubernetes/data-structures ]; then
  find devops-infra/kubernetes/data-structures -type f -name '*.yaml' -print0 \
    | xargs -0 -I{} bash -c "sed \"s|IMAGE_TAG|\${BACKEND_TAG}|g\" {} | kubectl apply -f -"
fi

echo ""
echo "Waiting for deployments to be ready..."
kubectl rollout status deployment/backend-deployment --timeout=120s || true
kubectl rollout status deployment/stack-deployment --timeout=120s || true
kubectl rollout status deployment/linkedlist-deployment --timeout=120s || true
kubectl rollout status deployment/graph-deployment --timeout=120s || true

echo ""
echo "Current pod status:"
kubectl get pods -A | head -n 50 || true
ENDSSH
"""
                }
            }
        }
    }

    post {
        success {
            echo "SUCCESS: backend pipeline (tag=${env.BACKEND_TAG})"
            echo "Deployed services:"
            echo "  - backend-service:${env.BACKEND_TAG}"
            echo "  - stack-service:${env.BACKEND_TAG}"
            echo "  - linkedlist-service:${env.BACKEND_TAG}"
            echo "  - graph-service:${env.BACKEND_TAG}"
            echo "  - postgres-db:${env.BACKEND_TAG}"
        }
        failure {
            echo "FAILED: backend pipeline"
            echo "Check the logs above for details"
        }
        always {
            echo "Build finished: ${currentBuild.currentResult}"
        }
    }
}