pipeline {
    agent any

    options {
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
    }

    parameters {
        string(name: 'EC2_HOST', defaultValue: '', description: 'EC2 private/public IP or DNS (optional if credential ec2-host-ip is set)')
        string(name: 'EC2_USER', defaultValue: 'ubuntu', description: 'EC2 SSH user')
        string(name: 'DEVOPS_REPO_URL', defaultValue: 'https://github.com/AlexBoyev/CloudRift-devops.git', description: 'DevOps repo URL')
        string(name: 'API_REPO_URL', defaultValue: 'https://github.com/AlexBoyev/CloudRift-backend.git', description: 'Backend repo URL')
        string(name: 'REPO_DIR', defaultValue: '/home/ubuntu/CloudRift-devops', description: 'DevOps repo dir on EC2')
        string(name: 'API_DIR', defaultValue: '/home/ubuntu/CloudRift-backend', description: 'Backend repo dir on EC2')
        string(name: 'BRANCH_NAME', defaultValue: 'main', description: 'Backend branch to deploy')
        string(name: 'MINIKUBE_PROFILE', defaultValue: 'minikube', description: 'Minikube profile name on EC2')
    }

    environment {
        // Jenkins credentials IDs
        // - github-pat-token : Username/Password (PAT in password field) OR Secret text (adjust if needed)
        // - ec2-ssh-key      : SSH private key credential
        // - ec2-host-ip      : Secret text containing your EC2 host/IP/DNS (fallback if param EC2_HOST is empty)
        GITHUB_PAT_CRED = 'github-pat-token'
        EC2_SSH_CRED    = 'ec2-ssh-key'
        EC2_HOST_FALLBACK_CRED = 'ec2-host-ip'

        EC2_HOST_EFFECTIVE = ''

        BACKEND_SHA = ''
        BACKEND_TAG = ''
    }

    stages {

        stage('Checkout DevOps Repo') {
            steps {
                checkout scm
            }
        }

        stage('Resolve EC2 Target') {
            steps {
                withCredentials([string(credentialsId: "${env.EC2_HOST_FALLBACK_CRED}", variable: 'EC2_HOST_FROM_CRED')]) {
                    script {
                        env.EC2_HOST_EFFECTIVE = (params.EC2_HOST?.trim())
                            ? params.EC2_HOST.trim()
                            : (env.EC2_HOST_FROM_CRED?.trim() ?: '')
                    }
                }

                script {
                    if (!env.EC2_HOST_EFFECTIVE?.trim()) {
                        error("EC2_HOST is required (set the EC2_HOST parameter or configure credential '${env.EC2_HOST_FALLBACK_CRED}')")
                    }
                    echo "Using EC2_HOST_EFFECTIVE=${env.EC2_HOST_EFFECTIVE}"
                }
            }
        }

        stage('SSH Preflight') {
            steps {
                withCredentials([
                    usernamePassword(credentialsId: "${env.GITHUB_PAT_CRED}", usernameVariable: 'GITHUB_PAT_USR', passwordVariable: 'GITHUB_PAT_PSW')
                ]) {
                    sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                        sh(label: 'SSH handshake test', script: '''#!/usr/bin/env bash
set -euo pipefail

: "${EC2_HOST_EFFECTIVE:?EC2_HOST is required}"
: "${EC2_USER:?EC2_USER is required}"

ssh -o StrictHostKeyChecking=no \
    -o PreferredAuthentications=publickey \
    -o PubkeyAuthentication=yes \
    "${EC2_USER}@${EC2_HOST_EFFECTIVE}" \
    'echo ok'
''')
                    }
                }
            }
        }

        stage('Sync DevOps Repo on EC2') {
            steps {
                withCredentials([
                    usernamePassword(credentialsId: "${env.GITHUB_PAT_CRED}", usernameVariable: 'GITHUB_PAT_USR', passwordVariable: 'GITHUB_PAT_PSW')
                ]) {
                    sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                        sh(label: 'Sync DevOps repo', script: '''#!/usr/bin/env bash
set -euo pipefail

: "${EC2_HOST_EFFECTIVE:?EC2_HOST is required}"
: "${EC2_USER:?EC2_USER is required}"
: "${GITHUB_PAT_PSW:?GITHUB_PAT_PSW missing}"
: "${DEVOPS_REPO_URL:?DEVOPS_REPO_URL missing}"
: "${REPO_DIR:?REPO_DIR missing}"

ssh -o StrictHostKeyChecking=no \
    -o PreferredAuthentications=publickey \
    -o PubkeyAuthentication=yes \
    "${EC2_USER}@${EC2_HOST_EFFECTIVE}" \
    "GITHUB_PAT='${GITHUB_PAT_PSW}' DEVOPS_REPO='${DEVOPS_REPO_URL}' REPO_DIR='${REPO_DIR}' bash -s" <<'SCRIPT'
set -euo pipefail

normalize_url() {
  local input="$1"
  if echo "$input" | grep -qiE '^git@github.com:'; then
    input=$(echo "$input" | sed -E 's|^git@github.com:|https://github.com/|')
  elif echo "$input" | grep -qiE '^ssh://git@github.com/'; then
    input=$(echo "$input" | sed -E 's|^ssh://git@github.com/|https://github.com/|')
  elif ! echo "$input" | grep -qiE '^https?://'; then
    input="https://$input"
  fi
  echo "$input"
}

FULL_URL="$(normalize_url "$DEVOPS_REPO")"
AUTH_URL="$FULL_URL"

if echo "$FULL_URL" | grep -qiE '^https://github.com/'; then
  AUTH_URL="$(echo "$FULL_URL" | sed -E "s|^https://github.com/|https://x-access-token:${GITHUB_PAT}@github.com/|")"
fi

if [ ! -d "$REPO_DIR/.git" ]; then
  mkdir -p "$REPO_DIR"
  echo "Cloning DevOps repo..."
  git clone "$AUTH_URL" "$REPO_DIR"
else
  echo "Updating DevOps repo..."
  cd "$REPO_DIR"
  git config --global --add safe.directory "$REPO_DIR" || true
  git remote set-url origin "$AUTH_URL" || true
  git fetch --all --prune
  git reset --hard origin/main
fi

cd "$REPO_DIR"
echo "DevOps commit: $(git rev-parse --short HEAD)"
SCRIPT
''')
                    }
                }
            }
        }

        stage('Sync Backend Repo on EC2') {
            steps {
                withCredentials([
                    usernamePassword(credentialsId: "${env.GITHUB_PAT_CRED}", usernameVariable: 'GITHUB_PAT_USR', passwordVariable: 'GITHUB_PAT_PSW')
                ]) {
                    sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                        sh(label: 'Sync backend repo', script: '''#!/usr/bin/env bash
set -euo pipefail

: "${EC2_HOST_EFFECTIVE:?EC2_HOST is required}"
: "${EC2_USER:?EC2_USER is required}"
: "${GITHUB_PAT_PSW:?GITHUB_PAT_PSW missing}"
: "${API_REPO_URL:?API_REPO_URL missing}"
: "${API_DIR:?API_DIR missing}"
: "${BRANCH_NAME:=main}"

ssh -o StrictHostKeyChecking=no \
    -o PreferredAuthentications=publickey \
    -o PubkeyAuthentication=yes \
    "${EC2_USER}@${EC2_HOST_EFFECTIVE}" \
    "BRANCH='${BRANCH_NAME}' GITHUB_PAT='${GITHUB_PAT_PSW}' API_REPO='${API_REPO_URL}' API_DIR='${API_DIR}' bash -s" <<'SCRIPT'
set -euo pipefail
: "${BRANCH:=main}"

normalize_url() {
  local input="$1"
  if echo "$input" | grep -qiE '^git@github.com:'; then
    input=$(echo "$input" | sed -E 's|^git@github.com:|https://github.com/|')
  elif echo "$input" | grep -qiE '^ssh://git@github.com/'; then
    input=$(echo "$input" | sed -E 's|^ssh://git@github.com/|https://github.com/|')
  elif ! echo "$input" | grep -qiE '^https?://'; then
    input="https://$input"
  fi
  echo "$input"
}

FULL_URL="$(normalize_url "$API_REPO")"
AUTH_URL="$FULL_URL"

if echo "$FULL_URL" | grep -qiE '^https://github.com/'; then
  AUTH_URL="$(echo "$FULL_URL" | sed -E "s|^https://github.com/|https://x-access-token:${GITHUB_PAT}@github.com/|")"
fi

if [ ! -d "$API_DIR/.git" ]; then
  mkdir -p "$API_DIR"
  echo "Cloning backend repo (branch: $BRANCH)..."
  git clone -b "$BRANCH" "$AUTH_URL" "$API_DIR"
else
  echo "Updating backend repo (branch: $BRANCH)..."
  cd "$API_DIR"
  git config --global --add safe.directory "$API_DIR" || true
  git remote set-url origin "$AUTH_URL" || true
  git fetch --all --prune
  git checkout "$BRANCH" || git checkout -b "$BRANCH" "origin/$BRANCH"
  git pull origin "$BRANCH" || {
    echo "Pull failed, resetting..."
    git fetch --all
    git reset --hard "origin/$BRANCH"
  }
fi

cd "$API_DIR"
echo "Backend SHA: $(git rev-parse --short HEAD)"
SCRIPT
''')
                    }
                }
            }
        }

        stage('Compute BACKEND_TAG') {
            steps {
                sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                    script {
                        def bn = (env.BUILD_NUMBER ?: "${currentBuild.number}").toString()

                        def sha = sh(
                            label: 'Read backend SHA from EC2',
                            script: """bash -lc '
set -euo pipefail
ssh -o StrictHostKeyChecking=no \\
    -o PreferredAuthentications=publickey \\
    -o PubkeyAuthentication=yes \\
    "${params.EC2_USER}@${env.EC2_HOST_EFFECTIVE}" \\
    "cd ${params.API_DIR} && git rev-parse --short HEAD | tr -d \\\\r"
'""",
                            returnStdout: true
                        ).trim()

                        if (!sha) {
                            error("ERROR: backend SHA came back empty; cannot build a tag")
                        }

                        env.BACKEND_SHA = sha
                        env.BACKEND_TAG = "backend-${bn}-${sha}"

                        if (!env.BACKEND_TAG?.trim() || env.BACKEND_TAG == 'null') {
                            error("ERROR: BACKEND_TAG resolved to an invalid value: '${env.BACKEND_TAG}'")
                        }

                        echo "Using BACKEND_SHA=${env.BACKEND_SHA}"
                        echo "Using BACKEND_TAG=${env.BACKEND_TAG}"
                    }
                }
            }
        }

        stage('Build Docker Images on EC2') {
            options {
                retry(3)
                timeout(time: 20, unit: 'MINUTES')
            }
            steps {
                sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                    sh(label: 'Build images', script: '''#!/usr/bin/env bash
set -euo pipefail

: "${EC2_HOST_EFFECTIVE:?EC2_HOST is required}"
: "${EC2_USER:?EC2_USER is required}"
: "${BACKEND_TAG:?BACKEND_TAG missing}"
: "${API_DIR:?API_DIR missing}"
: "${MINIKUBE_PROFILE:=minikube}"

ssh -o StrictHostKeyChecking=no \
    -o PreferredAuthentications=publickey \
    -o PubkeyAuthentication=yes \
    "${EC2_USER}@${EC2_HOST_EFFECTIVE}" \
    "API_DIR='${API_DIR}' MINIKUBE_PROFILE='${MINIKUBE_PROFILE}' BACKEND_TAG='${BACKEND_TAG}' bash -s" <<'SCRIPT'
set -euo pipefail

: "${API_DIR:?API_DIR missing}"
: "${MINIKUBE_PROFILE:=minikube}"
: "${BACKEND_TAG:?BACKEND_TAG missing}"

cd "$API_DIR"

eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"
echo "Building tag: ${BACKEND_TAG}"

cleanup_repo() {
  local repo="$1"
  docker images "$repo" --format "{{.Repository}}:{{.Tag}}" \
    | grep "^${repo}:" \
    | grep -v ":latest$" \
    | grep -v ":${BACKEND_TAG}$" \
    | xargs -r docker rmi -f || true
}

cleanup_repo backend-service
cleanup_repo stack-service
cleanup_repo linkedlist-service
cleanup_repo graph-service
cleanup_repo postgres-db

docker image prune -f || true

docker build -t "backend-service:${BACKEND_TAG}"    -f backend/Dockerfile     backend/
docker build -t "stack-service:${BACKEND_TAG}"      -f stack/Dockerfile       ./
docker build -t "linkedlist-service:${BACKEND_TAG}" -f linkedlist/Dockerfile  ./
docker build -t "graph-service:${BACKEND_TAG}"      -f graph/Dockerfile       ./
docker build -t "postgres-db:${BACKEND_TAG}"        -f database/Dockerfile    ./

echo "Images built:"
docker images | grep -E '^(backend-service|stack-service|linkedlist-service|graph-service|postgres-db)[[:space:]]' || true
SCRIPT
''')
                }
            }
        }

        stage('Deploy to Kubernetes on EC2') {
            steps {
                sshagent(credentials: ["${env.EC2_SSH_CRED}"]) {
                    sh(label: 'Deploy', script: '''#!/usr/bin/env bash
set -euo pipefail

: "${EC2_HOST_EFFECTIVE:?EC2_HOST is required}"
: "${EC2_USER:?EC2_USER is required}"
: "${BACKEND_TAG:?BACKEND_TAG missing}"
: "${REPO_DIR:?REPO_DIR missing}"
: "${API_DIR:?API_DIR missing}"
: "${MINIKUBE_PROFILE:=minikube}"

ssh -o StrictHostKeyChecking=no \
    -o PreferredAuthentications=publickey \
    -o PubkeyAuthentication=yes \
    "${EC2_USER}@${EC2_HOST_EFFECTIVE}" \
    "REPO_DIR='${REPO_DIR}' API_DIR='${API_DIR}' MINIKUBE_PROFILE='${MINIKUBE_PROFILE}' BACKEND_TAG='${BACKEND_TAG}' bash -s" <<'SCRIPT'
set -euo pipefail

: "${REPO_DIR:?REPO_DIR missing}"
: "${API_DIR:?API_DIR missing}"
: "${MINIKUBE_PROFILE:=minikube}"
: "${BACKEND_TAG:?BACKEND_TAG missing}"

eval "$(minikube -p "${MINIKUBE_PROFILE}" docker-env)"

cd "$REPO_DIR"
echo "Deploying tag ${BACKEND_TAG}..."

if [ -d devops-infra/k8s/backend ]; then
  find devops-infra/k8s/backend -type f -name '*.yaml' -print0 \
    | xargs -0 -I{} bash -lc "sed \"s|IMAGE_TAG|${BACKEND_TAG}|g\" {}" \
    | kubectl apply -f -
else
  echo "WARNING: devops-infra/k8s/backend not found. Skipping kubectl apply."
fi

kubectl get pods -A | head -n 50 || true
SCRIPT
''')
                }
            }
        }
    }

    post {
        success { echo "SUCCESS: backend pipeline (tag=${env.BACKEND_TAG})" }
        failure { echo "FAILED: backend pipeline" }
        always  { echo "Build finished: ${currentBuild.currentResult}" }
    }
}
